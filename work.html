<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Grid Canvas - Ayuna</title>
  <style>
    /* Previous styles remain unchanged */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --bg: #FFF9F3; --text: #3B3B3B; --border: #E5C299; --accent: #E4B77A;
      --grid-accent: rgba(238, 163, 58, 0.05); --box: #FFD6A4;
      --coord-text: rgba(228, 183, 122, 0.5); --coord-origin: rgba(228, 183, 122, 0.9);
      --port-radius: 4px; /* Reduced from 6px */
    }
    [data-theme="dark"] {
      --bg: #1C1E26; --text: #E8E6E3; --border: #4A4E69; --accent: #D4A574;
      --grid-accent: rgba(212, 165, 116, 0.05); --box: #2D3142;
      --coord-text: rgba(212, 165, 116, 0.4); --coord-origin: rgba(212, 165, 116, 0.8);
    }
    html, body { height: 100%; overflow: hidden; }
    body { background: var(--bg); font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: var(--text); transition: background-color 0.3s ease, color 0.3s ease; }
    canvas { position: fixed; inset: 0; cursor: grab; }
    canvas.dragging { cursor: grabbing; }
    .coordinate { position: absolute; font-size: 10px; font-family: 'Courier New', monospace; color: var(--coord-text); user-select: none; pointer-events: none; font-weight: 500; padding: 2px 4px; }
    .coordinate.origin { color: var(--coord-origin); font-weight: 700; font-size: 12px; background: var(--bg); border-radius: 4px; padding: 3px 6px; }
    .theme-toggle { position: fixed; top: 30px; right: 30px; background: var(--box); border: 2px solid var(--border); color: var(--text); width: 50px; height: 50px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.3rem; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); z-index: 1000; }
    .theme-toggle:hover { background: var(--accent); transform: rotate(180deg) scale(1.1); }
    .back-btn { position: fixed; top: 30px; left: 30px; background: var(--box); border: 2px solid var(--border); color: var(--text); padding: 12px 24px; border-radius: 10px; cursor: pointer; font-size: 1rem; font-weight: 600; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); z-index: 1000; }
    .back-btn:hover { background: var(--accent); transform: translateX(-5px); }
    .control-buttons { position: fixed; bottom: 30px; right: 30px; display: flex; flex-direction: column; gap: 10px; z-index: 1000; }
    .control-btn { background: var(--box); border: 2px solid var(--border); color: var(--text); width: 50px; height: 50px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.4rem; font-weight: 600; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); }
    .control-btn:hover { background: var(--accent); transform: scale(1.1); }
    .control-btn:active { transform: scale(0.95); }
    .position-info { position: fixed; bottom: 30px; left: 30px; background: var(--box); border: 2px solid var(--border); color: var(--text); padding: 12px 20px; border-radius: 10px; font-size: 0.9rem; font-weight: 600; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); z-index: 1000; font-family: 'Courier New', monospace; }
    .instructions { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--box); border: 2px solid var(--border); color: var(--text); padding: 30px 40px; border-radius: 15px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2); z-index: 999; text-align: center; opacity: 1; transition: opacity 0.5s ease; pointer-events: none; }
    .instructions.hidden { opacity: 0; }
    .instructions h3 { margin-bottom: 15px; font-size: 1.3rem; }
    .instructions p { margin: 8px 0; font-size: 0.95rem; opacity: 0.8; }
    .instructions code { background: var(--accent); padding: 2px 6px; border-radius: 4px; font-size: 0.85rem; }
    .node-editor {
      position: fixed;
      border-radius: 8px;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      font-size: 14px;
      text-align: center;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      z-index: 9999;
      box-sizing: border-box;
      outline: none;
      pointer-events: all;
      border: 2px solid var(--accent);
      background: var(--box);
      color: var(--text);
      resize: none;
      white-space: pre-wrap;
      overflow: hidden;
    }
    @media (max-width: 768px) {
      .back-btn, .theme-toggle { top: 15px; }
      .back-btn { left: 15px; padding: 10px 18px; font-size: 0.9rem; }
      .theme-toggle { right: 15px; width: 45px; height: 45px; }
      .control-buttons { bottom: 20px; right: 20px; }
      .control-btn { width: 45px; height: 45px; font-size: 1.2rem; }
      .position-info { bottom: 20px; left: 20px; font-size: 0.85rem; padding: 10px 16px; }
      .coordinate { font-size: 8px; }
      .coordinate.origin { font-size: 10px; }
      .grid-container { background-size: 45px 45px; }
      .instructions { padding: 25px 30px; max-width: 90%; }
      .instructions h3 { font-size: 1.1rem; }
      .instructions p { font-size: 0.85rem; }
    }
  </style>
<base target="_blank">
</head>
<body>
  <canvas id="gridCanvas"></canvas>
  <button class="back-btn" onclick="goBack()">‚Üê Back</button>
  <button class="theme-toggle" onclick="toggleTheme()">
    <span id="theme-icon">üåô</span>
  </button>
  <div class="control-buttons">
    <button class="control-btn" onclick="resetView()" title="Reset View">‚ü≤</button>
    <button class="control-btn" onclick="createNodeAtCenter()" title="Add Node">‚ûï</button>
  </div>
  <div class="position-info" id="positionInfo">Center: (0, 0)</div>
  <div class="instructions" id="instructions">
    <h3>Ayuna</h3>
    <p>This is a silent place...</p>
    <p>Dump Your Ideas without distraction...</p>
  </div>

  <script>
    // ========================================
    // THEME MANAGEMENT
    // ========================================
    function getSystemTheme() {
      return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    }
    function applyTheme(theme) {
      const html = document.documentElement, themeIcon = document.getElementById('theme-icon');
      if (theme === 'dark') {
        html.setAttribute('data-theme', 'dark');
        themeIcon.textContent = '‚òÄÔ∏è';
      } else {
        html.removeAttribute('data-theme');
        themeIcon.textContent = 'üåô';
      }
    }
    function initializeTheme() {
      const userPreference = localStorage.getItem('theme');
      applyTheme(userPreference || getSystemTheme());
    }
    function toggleTheme() {
      const html = document.documentElement, currentTheme = html.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      applyTheme(newTheme);
      localStorage.setItem('theme', newTheme);
      draw();
    }
    function watchSystemTheme() {
      if (window.matchMedia) {
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
          if (!localStorage.getItem('theme')) {
            applyTheme(e.matches ? 'dark' : 'light');
          }
        });
      }
    }
    function goBack() {
      window.location.href = 'home.html';
    }

    const canvas = document.getElementById('gridCanvas');
    const ctx = canvas.getContext('2d');
    const positionInfo = document.getElementById('positionInfo');
    const instructions = document.getElementById('instructions');

    let width = window.innerWidth, height = window.innerHeight;
    canvas.width = width; canvas.height = height;

    let GRID_SIZE = 60; // This will be the BASE grid size
    let isDragging = false, startX = 0, startY = 0;
    let offsetX = width / 2, offsetY = height / 2;
    
    // NEW ZOOM VARS
    let zoom = 1;
    const ZOOM_MIN = 0.65;
    const ZOOM_MAX = 1.3;
    const ZOOM_SENSITIVITY = 0.0015;
    // This is the *actual* scale used for drawing, calculated in draw()
    let effectiveScale = GRID_SIZE * zoom; 
    // END NEW ZOOM VARS

    setTimeout(() => instructions.classList.add('hidden'), 4000);

    let nodes = [], nodeIdCounter = 0;
    let connections = [], connectionIdCounter = 0;
    let isDraggingNode = false, draggingNodeId = null;
    let isConnecting = false, connectingFrom = null;
    let mouseX = 0, mouseY = 0;

    const MIN_NODE_WIDTH = 120; // Base width at zoom = 1
    const MIN_NODE_HEIGHT = 60; // Base height at zoom = 1
    const MAX_NODE_WIDTH = 250; 
    const NODE_BASE_FONT_SIZE = 14;
    const NODE_FONT = `normal ${NODE_BASE_FONT_SIZE}px "Segoe UI", Tahoma, Geneva, Verdana, sans-serif`;
    const NODE_LINE_HEIGHT = 18; // Base line height at zoom = 1
    const NODE_PADDING_H = 15; // Base padding at zoom = 1
    const NODE_PADDING_V = 10; // Base padding at zoom = 1
    const portRadius = 4; // Base radius at zoom = 1
    const nodeRadius = 8; // Base corner radius at zoom = 1

    function getGridSize() {
      // This now returns the BASE grid size for the current viewport
      return window.innerWidth <= 768 ? 45 : 60;
    }

    function loadFromStorage() {
      const savedNodes = localStorage.getItem('ayuna-nodes');
      const savedConnections = localStorage.getItem('ayuna-connections');
      const savedOffset = localStorage.getItem('ayuna-offset');
      if (savedNodes) {
        nodes = JSON.parse(savedNodes);
        nodeIdCounter = nodes.reduce((max, node) => Math.max(max, parseInt(node.id.split('-')[1]) || 0), 0);
        
        nodes.forEach(node => {
            if (!node.width || !node.height || !node._lines) {
              // Will be recalculated on first draw, but we can't do it
              // here as ctx isn't fully ready for font measurement yet.
            }
        });

      }
      if (savedConnections) {
        connections = JSON.parse(savedConnections);
        connectionIdCounter = connections.reduce((max, conn) => Math.max(max, parseInt(conn.id.split('-')[1]) || 0), 0);
      }
      if (savedOffset) {
         try {
            const offsetData = JSON.parse(savedOffset);
            offsetX = offsetData.x || width / 2;
            offsetY = offsetData.y || height / 2;
         } catch(e) {
            offsetX = width / 2; offsetY = height / 2;
         }
      } else {
        offsetX = width / 2; offsetY = height / 2;
      }

      // LOAD ZOOM
      const savedZoom = localStorage.getItem('ayuna-zoom');
      if (savedZoom) {
        zoom = parseFloat(savedZoom) || 1;
      }
    }

    function saveToStorage() {
      localStorage.setItem('ayuna-nodes', JSON.stringify(nodes));
      localStorage.setItem('ayuna-connections', JSON.stringify(connections));
      localStorage.setItem('ayuna-offset', JSON.stringify({ x: offsetX, y: offsetY }));
      localStorage.setItem('ayuna-zoom', zoom); // SAVE ZOOM
    }

    function createNode(gridX, gridY, text = 'New Node') {
      const size = calculateNodeSize(text);
      const node = { 
        id: `node-${++nodeIdCounter}`, 
        x: gridX, 
        y: gridY, 
        text: text,
        width: size.width,   // Base width (pixels at zoom=1)
        height: size.height, // Base height (pixels at zoom=1)
        _lines: size.lines
      };
      nodes.push(node);
      pushSnapshot('add-node'); 
      draw();
      return node;
    }

    function createNodeAtCenter() {
      const centerGrid = getGridPosition(window.innerWidth / 2, window.innerHeight / 2);
      const offset = Math.floor(Math.random() * 3) - 1;
      createNode(centerGrid.x + offset, centerGrid.y + offset);
    }

    function getNodeAt(screenX, screenY) {
      // Find in reverse to prioritize top nodes
      for (let i = nodes.length - 1; i >= 0; i--) {
        const node = nodes[i];
        const nodeScreenX = node.x * effectiveScale + offsetX;
        const nodeScreenY = node.y * effectiveScale + offsetY;
        
        // Scale node width and height for hit detection
        const w = node.width * zoom;
        const h = node.height * zoom;

        if (screenX >= nodeScreenX - w/2 && screenX <= nodeScreenX + w/2 &&
            screenY >= nodeScreenY - h/2 && screenY <= nodeScreenY + h/2) {
          return node;
        }
      }
      return null;
    }

    function getPortAt(screenX, screenY) {
      for (const node of nodes) {
        const nodeCenterX = node.x * effectiveScale + offsetX;
        const nodeCenterY = node.y * effectiveScale + offsetY;
        
        const w_half = (node.width * zoom) / 2;

        const ports = [
          // { side: 'top', x: nodeCenterX, y: nodeCenterY - (node.height * zoom) / 2 }, 
          // { side: 'bottom', x: nodeCenterX, y: nodeCenterY + (node.height * zoom) / 2 }, 
          { side: 'left', x: nodeCenterX - w_half, y: nodeCenterY }, 
          { side: 'right', x: nodeCenterX + w_half, y: nodeCenterY }
        ];
        
        // Scale hit area by zoom
        const hitRadius = (portRadius + 4) * zoom;

        for (const port of ports) {
          const dist = Math.hypot(screenX - port.x, screenY - port.y);
          if (dist <= hitRadius) {
            return { nodeId: node.id, side: port.side, node, ...port };
          }
        }
      }
      return null;
    }

    function getGridPosition(screenX, screenY) {
      // effectiveScale is the *actual* (zoomed) grid size in pixels
      return { x: (screenX - offsetX) / effectiveScale, y: (screenY - offsetY) / effectiveScale };
    }

    function drawPorts(node) {
      const style = getComputedStyle(document.body);
      const nodeCenterX = node.x * effectiveScale + offsetX;
      const nodeCenterY = node.y * effectiveScale + offsetY;
      
      const w_half = (node.width * zoom) / 2;
      // const h_half = (node.height * zoom) / 2; // If top/bottom ports are re-added

      const ports = [
        // { x: nodeCenterX, y: nodeCenterY - h_half }, 
        // { x: nodeCenterX, y: nodeCenterY + h_half }, 
        { x: nodeCenterX - w_half, y: nodeCenterY }, 
        { x: nodeCenterX + w_half, y: nodeCenterY }
      ];

      ctx.fillStyle = style.getPropertyValue('--accent').trim();
      
      const textColor = style.getPropertyValue('--text').trim();
      ctx.strokeStyle = textColor.includes('rgba') ? textColor : textColor.replace(')', ', 0.5)').replace('rgb', 'rgba');
      ctx.lineWidth = 1.5; // This will look thinner when zoomed out, which is fine

      // Scale port radius
      const r = portRadius * zoom;

      ports.forEach(port => {
        ctx.beginPath();
        ctx.arc(port.x, port.y, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
      });
    }

    function drawNodes() {
      const style = getComputedStyle(document.body);
      ctx.textAlign = 'center'; 
      ctx.textBaseline = 'middle';
      // Set font size based on zoom
      ctx.font = `normal ${NODE_BASE_FONT_SIZE * zoom}px "Segoe UI", Tahoma, Geneva, Verdana, sans-serif`;

      nodes.forEach(node => {
        if (!node._lines) {
            const size = calculateNodeSize(node.text);
            node.width = size.width;
            node.height = size.height;
            node._lines = size.lines;
        }

        const screenX = node.x * effectiveScale + offsetX;
        const screenY = node.y * effectiveScale + offsetY;

        // Scale width, height, and radius by zoom
        const w = node.width * zoom;
        const h = node.height * zoom;
        const r = nodeRadius * zoom;

        // Shadow
        ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
        ctx.shadowBlur = 8 * zoom; 
        ctx.shadowOffsetX = 2 * zoom; 
        ctx.shadowOffsetY = 2 * zoom;

        // Node body - USE DYNAMIC SCALED SIZE
        ctx.fillStyle = style.getPropertyValue('--box').trim();
        ctx.beginPath(); 
        ctx.roundRect(screenX - w/2, screenY - h/2, w, h, r);
        ctx.fill();

        // Reset shadow
        ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0;

        // Border
        ctx.strokeStyle = style.getPropertyValue('--border').trim();
        ctx.lineWidth = 2; // Also gets thinner on zoom out
        ctx.stroke();

        // Text - NOW MULTILINE
        ctx.fillStyle = style.getPropertyValue('--text').trim();
        const lines = node._lines || [];
        
        // Scale line height
        const scaledLineHeight = NODE_LINE_HEIGHT * zoom;
        const totalTextHeight = lines.length * scaledLineHeight;
        
        const startY = screenY - (totalTextHeight / 2) + (scaledLineHeight / 2);

        lines.forEach((line, index) => {
          const y = startY + (index * scaledLineHeight);
          ctx.fillText(line, screenX, y);
        });

        // Draw ports on top
        drawPorts(node);
      });
    }

    function drawConnections() {
      const style = getComputedStyle(document.body);
      ctx.strokeStyle = style.getPropertyValue('--accent').trim();
      ctx.lineWidth = 2; // Thinner on zoom out

      connections.forEach(conn => {
        const fromNode = nodes.find(n => n.id === conn.from.nodeId);
        const toNode = nodes.find(n => n.id === conn.to.nodeId);
        if (!fromNode || !toNode) return;

        const fromPos = getPortPosition(fromNode, conn.from.side);
        const toPos = getPortPosition(toNode, conn.to.side);
        
        let controlX, controlY, controlX2, controlY2;
        
        // Use horizontal control points for vertical connections (top/bottom)
        if (conn.from.side === 'top' || conn.from.side === 'bottom' || conn.to.side === 'top' || conn.to.side === 'bottom') {
            const curveAmount = Math.max(30, Math.abs(fromPos.y - toPos.y) * 0.3);
            controlX = fromPos.x;
            controlY = fromPos.y + (conn.from.side === 'bottom' ? curveAmount : -curveAmount);
            controlX2 = toPos.x;
            controlY2 = toPos.y + (conn.to.side === 'top' ? curveAmount : -curveAmount);
        } else {
            // Use vertical control points for horizontal connections (left/right)
            // Scale curve amount by zoom to keep shape
            const curveAmount = Math.max(30 * zoom, Math.abs(fromPos.x - toPos.x) * 0.3);
            controlX = fromPos.x + (conn.from.side === 'right' ? curveAmount : -curveAmount);
            controlY = fromPos.y;
            controlX2 = toPos.x + (conn.to.side === 'left' ? curveAmount : -curveAmount);
            controlY2 = toPos.y;
        }
        
        ctx.beginPath();
        ctx.moveTo(fromPos.x, fromPos.y);
        ctx.bezierCurveTo(controlX, controlY, controlX2, controlY2, toPos.x, toPos.y);
        ctx.stroke();
      });

      // Connection preview
      if (isConnecting && connectingFrom) {
        const fromNode = nodes.find(n => n.id === connectingFrom.nodeId);
        if (fromNode) {
          const fromPos = getPortPosition(fromNode, connectingFrom.side);
          ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(fromPos.x, fromPos.y);
          ctx.lineTo(mouseX, mouseY); ctx.stroke(); ctx.setLineDash([]);
        }
      }
    }

    function getPortPosition(node, side) {
      const nodeCenterX = node.x * effectiveScale + offsetX;
      const nodeCenterY = node.y * effectiveScale + offsetY;
      
      const w_half = (node.width * zoom) / 2;
      // const h_half = (node.height * zoom) / 2;

      switch (side) {
        // case 'top': return { x: nodeCenterX, y: nodeCenterY - h_half };
        // case 'bottom': return { x: nodeCenterX, y: nodeCenterY + h_half };
        case 'left': return { x: nodeCenterX - w_half, y: nodeCenterY };
        case 'right': return { x: nodeCenterX + w_half, y: nodeCenterY };
        default: return { x: nodeCenterX, y: nodeCenterY };
      }
    }

    /* Calculate node size based on text content (returns BASE size at zoom=1) */
    function calculateNodeSize(text) {
        ctx.font = NODE_FONT; // Use the BASE font for measurement
        const lines = [];
        const words = String(text || '').split(' ');
        let currentLine = '';
        let maxWidth = 0;

        const maxTextWidth = MAX_NODE_WIDTH - (NODE_PADDING_H * 2);

        words.forEach(word => {
            const testLine = currentLine ? `${currentLine} ${word}` : word;
            const metrics = ctx.measureText(testLine);
            if (metrics.width > maxTextWidth && currentLine) {
                lines.push(currentLine);
                maxWidth = Math.max(maxWidth, ctx.measureText(currentLine).width);
                currentLine = word;
            } else {
                currentLine = testLine;
            }
        });
        lines.push(currentLine);
        maxWidth = Math.max(maxWidth, ctx.measureText(currentLine).width);

        const calculatedWidth = maxWidth + (NODE_PADDING_H * 2);
        const calculatedHeight = (lines.length * NODE_LINE_HEIGHT) + (NODE_PADDING_V * 2);

        return {
            lines: lines,
            width: Math.max(MIN_NODE_WIDTH, Math.min(MAX_NODE_WIDTH, calculatedWidth)),
            height: Math.max(MIN_NODE_HEIGHT, calculatedHeight)
        };
    }


    /* ------------------ Hierarchical auto-layout & group-drag + undo/redo ------------------ */
    const LAYOUT = {
      H_SPACING: 4.0, 
      V_SPACING: 1.5,
      MAX_UNDO: 60
    };

    const undoStack = [];
    const redoStack = [];

    function pushSnapshot(label = '') {
      undoStack.push({
        label,
        nodes: JSON.parse(JSON.stringify(nodes)),
        connections: JSON.parse(JSON.stringify(connections)),
        offsetX, offsetY,
        zoom // ADD ZOOM
      });
      if (undoStack.length > LAYOUT.MAX_UNDO) undoStack.shift();
      redoStack.length = 0;
      saveToStorage(); 
    }

    function undo() {
      if (!undoStack.length) return;
      const snap = undoStack.pop();
      redoStack.push({
        nodes: JSON.parse(JSON.stringify(nodes)),
        connections: JSON.parse(JSON.stringify(connections)),
        offsetX, offsetY,
        zoom // ADD ZOOM
      });
      nodes = snap.nodes;
      connections = snap.connections;
      offsetX = snap.offsetX; 
      offsetY = snap.offsetY;
      zoom = snap.zoom || 1; // RESTORE ZOOM
      draw();
      saveToStorage();
    }

    function redo() {
      if (!redoStack.length) return;
      const snap = redoStack.pop();
      undoStack.push({
        nodes: JSON.parse(JSON.stringify(nodes)),
        connections: JSON.parse(JSON.stringify(connections)),
        offsetX, offsetY,
        zoom // ADD ZOOM
      });
      nodes = snap.nodes;
      connections = snap.connections;
      offsetX = snap.offsetX; 
      offsetY = snap.offsetY;
      zoom = snap.zoom || 1; // RESTORE ZOOM
      draw();
      saveToStorage();
    }

    function nodeById(id) { return nodes.find(n => n.id === id); }

    function buildDirectedMaps(componentIds = null) {
      const children = new Map(), incoming = new Map();
      const set = componentIds ? new Set(componentIds) : null;
      for (const n of nodes) {
        if (!set || set.has(n.id)) {
          children.set(n.id, []);
          incoming.set(n.id, 0);
        }
      }
      for (const c of connections) {
        const a = c.from.nodeId, b = c.to.nodeId;
        if ((set && (!set.has(a) || !set.has(b))) ) continue;
        if (!children.has(a)) children.set(a, []);
        if (!incoming.has(b)) incoming.set(b, 0);
        children.get(a).push(b);
        incoming.set(b, (incoming.get(b) || 0) + 1);
      }
      return { children, incoming };
    }

    function connectedComponent(startId) {
      const seen = new Set([startId]);
      const q = [startId];
      while (q.length) {
        const cur = q.shift();
        for (const c of connections) {
          const a = c.from.nodeId, b = c.to.nodeId;
          if (a === cur && !seen.has(b)) { seen.add(b); q.push(b); }
          if (b === cur && !seen.has(a)) { seen.add(a); q.push(a); }
        }
      }
      return Array.from(seen);
    }

    function computeSubtreeSize(id, childrenMap, memo = new Map()) {
      if (memo.has(id)) return memo.get(id);
      const ch = childrenMap.get(id) || [];
      if (!ch.length) { memo.set(id, 1); return 1; }
      let sum = 0;
      for (const c of ch) sum += computeSubtreeSize(c, childrenMap, memo);
      memo.set(id, sum);
      return sum;
    }

    function assignYPositions(rootId, childrenMap) {
      const yMap = new Map(), depthMap = new Map();
      let nextY = 0;
      function dfs(u, depth) {
        depthMap.set(u, depth);
        const ch = childrenMap.get(u) || [];
        if (ch.length === 0) { yMap.set(u, nextY * LAYOUT.V_SPACING); nextY++; return; }
        for (const c of ch) dfs(c, depth + 1);
        const avg = ch.reduce((s, id) => s + yMap.get(id), 0) / ch.length;
        yMap.set(u, avg);
      }
      dfs(rootId, 0);
      return { yMap, depthMap };
    }

    function layoutTreeAnchored(rootId, componentIds) {
      const { children, incoming } = buildDirectedMaps(componentIds);
      const sizeMemo = new Map();
      for (const [id, ch] of children) {
        ch.sort((a,b) => {
          const sa = computeSubtreeSize(a, children, sizeMemo);
          const sb = computeSubtreeSize(b, children, sizeMemo);
          return sb - sa;
        });
      }
      const { yMap, depthMap } = assignYPositions(rootId, children);
      const rootNode = nodeById(rootId);
      if (!rootNode) return;
      const rootComputedY = yMap.get(rootId) || 0;
      const targetRootY = rootNode.y;
      const deltaY = targetRootY - rootComputedY;
      for (const id of componentIds) {
        if (!yMap.has(id)) continue;
        const node = nodeById(id);
        if (!node) continue;
        const d = depthMap.get(id) || 0;
        const newX = rootNode.x + d * LAYOUT.H_SPACING;
        const newY = yMap.get(id) + deltaY;
        node.x = newX; node.y = newY;
      }
    }

    function layoutComponent(componentIds) {
      const { children, incoming } = buildDirectedMaps(componentIds);
      const roots = [];
      for (const id of componentIds) {
        if (!incoming.has(id) || incoming.get(id) === 0) roots.push(id);
      }
      if (!roots.length && componentIds.length > 0) {
        let best = componentIds[0], bestDeg = -1;
        for (const id of componentIds) {
          const deg = (children.get(id) || []).length;
          if (deg > bestDeg) { bestDeg = deg; best = id; }
        }
        roots.push(best);
      }
      for (const r of roots) {
        layoutTreeAnchored(r, componentIds);
      }
      draw();
    }

    function relaxLayoutForNode(nodeId) {
      const comp = connectedComponent(nodeId);
      if (comp.length <= 1) return;
      pushSnapshot('layout-change');
      layoutComponent(comp);
    }

    let draggingGroup = null; 

    function beginGroupDrag(nodeId, startClientX, startClientY) {
      if (!nodeHasConnections(nodeId)) return null;
      draggingGroup = connectedComponent(nodeId);
      draggingGroup.prevPointer = { x: startClientX, y: startClientY };
      return draggingGroup;
    }

    function performGroupDrag(deltaPxX, deltaPxY) {
      if (!draggingGroup) return;
      // Use effectiveScale to convert pixel delta to grid delta
      const dxGrid = deltaPxX / effectiveScale;
      const dyGrid = deltaPxY / effectiveScale;
      for (const id of draggingGroup) {
        const n = nodeById(id);
        if (!n) continue;
        n.x += dxGrid;
        n.y += dyGrid;
      }
      draw();
    }

    function endGroupDrag() {
      if (!draggingGroup) return;
      pushSnapshot('group-drag');
      draggingGroup = null;
    }

    function nodeHasConnections(nodeId) {
      return connections.some(c => c.from.nodeId === nodeId || c.to.nodeId === nodeId);
    }
    
    /* ------------------ End of Hierarchical Layout Code ------------------ */


    function draw() {
      const style = getComputedStyle(document.body);
      ctx.clearRect(0, 0, width, height);

      // Grid
      GRID_SIZE = getGridSize(); // Get the BASE size
      effectiveScale = GRID_SIZE * zoom; // Calculate the *actual* scale

      const worldStartX = -offsetX, worldStartY = -offsetY;
      const startGridX = Math.floor(worldStartX / effectiveScale) - 1;
      const startGridY = Math.floor(worldStartY / effectiveScale) - 1;
      const endGridX = startGridX + Math.ceil(width / effectiveScale) + 2;
      const endGridY = startGridY + Math.ceil(height / effectiveScale) + 2;

      ctx.strokeStyle = style.getPropertyValue('--grid-accent').trim();
      ctx.lineWidth = 1; ctx.beginPath();
      for (let gx = startGridX; gx <= endGridX; gx++) {
        const x = gx * effectiveScale + offsetX;
        ctx.moveTo(x, 0); ctx.lineTo(x, height);
      }
      for (let gy = startGridY; gy <= endGridY; gy++) {
        const y = gy * effectiveScale + offsetY;
        ctx.moveTo(0, y); ctx.lineTo(width, y);
      }
      ctx.stroke();

      drawConnections();
      drawNodes();
      updatePositionInfo();
    }

    function updatePositionInfo() {
      const centerGridX = (width / 2 - offsetX) / effectiveScale;
      const centerGridY = (height / 2 - offsetY) / effectiveScale;
      positionInfo.textContent = `Center: (${centerGridX.toFixed(1)}, ${centerGridY.toFixed(1)}) | Zoom: ${Math.round(zoom * 100)}%`;
    }


    canvas.addEventListener('pointerdown', e => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left, y = e.clientY - rect.top;
      
      const port = getPortAt(x, y);
      if (port) {
        isConnecting = true;
        connectingFrom = { nodeId: port.nodeId, side: port.side };
        canvas.style.cursor = 'crosshair';
        try { canvas.setPointerCapture(e.pointerId); } catch(e) {}
        return;
      }

      const node = getNodeAt(x, y);
      if (node) {
        isDraggingNode = true; draggingNodeId = node.id;
        canvas.style.cursor = 'grabbing';
        if (beginGroupDrag(node.id, e.clientX, e.clientY)) { }
        try { canvas.setPointerCapture(e.pointerId); } catch(e) {}
        return;
      }

      isDragging = true; canvas.classList.add('dragging');
      startX = e.clientX - offsetX; startY = e.clientY - offsetY;
      try { canvas.setPointerCapture(e.pointerId); } catch(e) {}
    });

    window.addEventListener('pointermove', e => {
      mouseX = e.clientX; mouseY = e.clientY;
      
      if (isDraggingNode && draggingNodeId) {
        if (draggingGroup) {
          const deltaPxX = mouseX - draggingGroup.prevPointer.x;
          const deltaPxY = mouseY - draggingGroup.prevPointer.y;
          performGroupDrag(deltaPxX, deltaPxY);
          draggingGroup.prevPointer.x = mouseX;
          draggingGroup.prevPointer.y = mouseY;
        } else {
          const gridPos = getGridPosition(mouseX, mouseY);
          const node = nodeById(draggingNodeId);
          if (node) { node.x = gridPos.x; node.y = gridPos.y; draw(); }
        }
      } else if (isConnecting) {
        draw();
      } else if (isDragging) {
        offsetX = e.clientX - startX; offsetY = e.clientY - startY; draw();
      } else {
        const rect = canvas.getBoundingClientRect();
        const port = getPortAt(e.clientX - rect.left, e.clientY - rect.top);
        canvas.style.cursor = port ? 'crosshair' : 'grab';
      }
    });

    window.addEventListener('pointerup', e => {
      const wasDraggingNode = isDraggingNode;
      
      if (isConnecting && connectingFrom) {
        const rect = canvas.getBoundingClientRect();
        const targetPort = getPortAt(e.clientX - rect.left, e.clientY - rect.top);
        
        if (targetPort && 
            targetPort.nodeId !== connectingFrom.nodeId) {
            
          const exists = connections.some(conn => 
            (conn.from.nodeId === connectingFrom.nodeId && conn.from.side === connectingFrom.side &&
             conn.to.nodeId === targetPort.nodeId && conn.to.side === targetPort.side) ||
            (conn.from.nodeId === targetPort.nodeId && conn.from.side === targetPort.side &&
             conn.to.nodeId === connectingFrom.nodeId && conn.to.side === connectingFrom.side)
          );
          
          if (!exists) {
            connections.push({
              id: `conn-${++connectionIdCounter}`,
              from: { nodeId: connectingFrom.nodeId, side: connectingFrom.side },
              to: { nodeId: targetPort.nodeId, side: targetPort.side }
            });
            pushSnapshot('add-connection');
            relaxLayoutForNode(connectingFrom.nodeId); 
          }
        }
      }
      
      if (wasDraggingNode) {
        if (draggingGroup) {
          endGroupDrag();
        } else {
          pushSnapshot('move-node');
        }
      }
      
      isDragging = false; isDraggingNode = false; draggingNodeId = null;
      isConnecting = false; connectingFrom = null;
      canvas.classList.remove('dragging'); canvas.style.cursor = 'grab';
      try { canvas.releasePointerCapture(e.pointerId); } catch(e) {}
      
      if (!isConnecting && !wasDraggingNode) {
        pushSnapshot('pan');
      }
    });

    canvas.addEventListener('dblclick', e => {
      const rect = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      const node = getNodeAt(clickX, clickY);
      
      if (!node) return;

      document.querySelectorAll('.node-editor').forEach(el => el.remove());

      const screenX = node.x * effectiveScale + offsetX;
      const screenY = node.y * effectiveScale + offsetY;

      // Scale all editor properties by zoom
      const w = node.width * zoom;
      const h = node.height * zoom;
      const p_v = NODE_PADDING_V * zoom;
      const p_h = NODE_PADDING_H * zoom;
      const line_h = NODE_LINE_HEIGHT * zoom;
      const font_size = NODE_BASE_FONT_SIZE * zoom;

      const textarea = document.createElement('textarea');
      textarea.className = 'node-editor';
      textarea.value = node.text;
      
      textarea.style.left = `${screenX - w/2}px`;
      textarea.style.top = `${screenY - h/2}px`;
      textarea.style.width = `${w}px`;
      textarea.style.height = `${h}px`;
      textarea.style.padding = `${p_v}px ${p_h}px`;
      textarea.style.lineHeight = `${line_h}px`;
      textarea.style.font = `normal ${font_size}px "Segoe UI", Tahoma, Geneva, Verdana, sans-serif`;
      
      const finish = (shouldSave = true) => {
        if (shouldSave && textarea.value.trim() && node.text !== textarea.value.trim()) {
          const newText = textarea.value.trim();
          // Recalculate BASE size
          const size = calculateNodeSize(newText);
          node.text = newText;
          node.width = size.width;
          node.height = size.height;
          node._lines = size.lines;
          pushSnapshot('edit-node'); 
          draw();
        } else {
          draw();
        }
        textarea.remove();
        canvas.style.pointerEvents = 'auto';
      };

      textarea.addEventListener('blur', () => finish(true));
      textarea.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') { 
          e.preventDefault(); 
          finish(true); 
        }
        else if (e.key === 'Escape') { 
          e.preventDefault(); 
          finish(false); 
        }
      });

      document.body.appendChild(textarea);
      canvas.style.pointerEvents = 'none';
      requestAnimationFrame(() => { textarea.focus(); textarea.select(); });
    });

    canvas.addEventListener('click', e => {
      const rect = canvas.getBoundingClientRect();
      const gridPos = getGridPosition(e.clientX - rect.left, e.clientY - rect.top);
      // console.log(`Clicked: (${gridPos.x.toFixed(2)}, ${gridPos.y.toFixed(2)})`);
    });


    canvas.addEventListener('touchstart', e => {
      if (e.touches.length === 1) {
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches[0];
        const x = touch.clientX - rect.left, y = touch.clientY - rect.top;
        const node = getNodeAt(x, y);
        
        if (node) {
          isDraggingNode = true; draggingNodeId = node.id;
          if (beginGroupDrag(node.id, touch.clientX, touch.clientY)) { }
        } else {
          isDragging = true; canvas.classList.add('dragging');
          startX = touch.clientX - offsetX; startY = touch.clientY - offsetY;
        }
      }
    }, { passive: false });

    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      if (e.touches.length === 1) {
        const touch = e.touches[0];
        
        if (isDraggingNode && draggingNodeId) {
          if (draggingGroup) {
            const deltaPxX = touch.clientX - draggingGroup.prevPointer.x;
            const deltaPxY = touch.clientY - draggingGroup.prevPointer.y;
            performGroupDrag(deltaPxX, deltaPxY);
            draggingGroup.prevPointer.x = touch.clientX;
            draggingGroup.prevPointer.y = touch.clientY;
          } else {
            const gridPos = getGridPosition(touch.clientX, touch.clientY);
            const node = nodeById(draggingNodeId);
            if (node) { node.x = gridPos.x; node.y = gridPos.y; draw(); }
          }
        } else if (isDragging) {
          offsetX = touch.clientX - startX; offsetY = touch.clientY - startY; draw();
        }
      }
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      const wasDraggingNode = isDraggingNode; 
    
      if (wasDraggingNode) {
        if (draggingGroup) { endGroupDrag(); } 
        else { pushSnapshot('move-node'); }
      } else if (isDragging) {
        pushSnapshot('pan');
      }
      
      isDragging = false; isDraggingNode = false; draggingNodeId = null;
      canvas.classList.remove('dragging');
    });

    window.addEventListener('resize', () => {
      width = window.innerWidth; height = window.innerHeight;
      canvas.width = width; canvas.height = height; draw();
    });

    // REPLACED wheel listener for ZOOM
    canvas.addEventListener("wheel", (e) => {
        e.preventDefault();

        // Calculate new zoom
        const zoomFactor = 1 - e.deltaY * ZOOM_SENSITIVITY;
        const newZoom = Math.min(ZOOM_MAX, Math.max(ZOOM_MIN, zoom * zoomFactor));

        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Use the *current* global effectiveScale
        const worldX = (mouseX - offsetX) / effectiveScale;
        const worldY = (mouseY - offsetY) / effectiveScale;

        // Update global zoom
        zoom = newZoom;

        // Get base grid size and calculate NEW effective scale
        GRID_SIZE = getGridSize(); 
        effectiveScale = GRID_SIZE * zoom; 

        // Apply zoom by adjusting offset
        offsetX = mouseX - worldX * effectiveScale;
        offsetY = mouseY - worldY * effectiveScale;

        // Save new zoom and offset (no need to push to undo for every wheel tick)
        localStorage.setItem('ayuna-zoom', zoom);
        localStorage.setItem('ayuna-offset', JSON.stringify({ x: offsetX, y: offsetY }));

        draw();
    }, { passive: false });
    
    canvas.addEventListener('contextmenu', e => e.preventDefault());


    function resetView() {
      offsetX = width / 2; offsetY = height / 2;
      zoom = 1; // RESET ZOOM
      pushSnapshot('reset-view');
      draw();
      console.log('Reset to origin (0,0)');
    }

    document.addEventListener('keydown', (e) => {
      const active = document.activeElement;
      const isTyping = active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.classList.contains('node-editor'));
      if (isTyping) {
        if (e.key === 'Escape') active.blur();
        return;
      }

      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z' && !e.shiftKey) {
        undo(); e.preventDefault(); return;
      }
      if ((e.ctrlKey || e.metaKey) && (e.key.toLowerCase() === 'y' || (e.shiftKey && e.key.toLowerCase() === 'z'))) {
        redo(); e.preventDefault(); return;
      }

      if (e.key.toLowerCase() === 'r' || e.key === '0') {
        e.preventDefault(); resetView(); return;
      }
      if (e.key === '+' || e.key === '=') {
        e.preventDefault(); createNodeAtCenter(); return;
      }
      if (e.key.startsWith('Arrow')) {
        e.preventDefault();
        // Pan step is based on BASE grid size, so it feels consistent
        const step = (e.shiftKey ? 4 : 1) * (getGridSize() / 4);
        switch (e.key) {
          case 'ArrowUp': offsetY += step; break;
          case 'ArrowDown': offsetY -= step; break;
          case 'ArrowLeft': offsetX += step; break;
          case 'ArrowRight': offsetX -= step; break;
        }
        draw(); return;
      }
    });


    window.addEventListener('DOMContentLoaded', () => {
      initializeTheme(); watchSystemTheme(); loadFromStorage();
      
      if (undoStack.length === 0) {
        // Ensure nodes are sized before initial snapshot
        // We need ctx to be ready, so we do it here
        nodes.forEach(node => {
            if (!node.width || !node.height || !node._lines) {
                const size = calculateNodeSize(node.text);
                node.width = size.width;
                node.height = size.height;
                node._lines = size.lines;
            }
        });
        pushSnapshot('initial-load');
      }
      draw();
      console.log('‚úÖ Grid canvas with DYNAMIC nodes, H-layout & undo/redo initialized');
      console.log('üéÆ Controls: Drag=pan, Scroll=zoom, Port drag=connect, Double-click=edit, +=add node');
    });
  </script>
</body>
</html>